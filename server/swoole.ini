server.host=127.0.0.1
server.port=80

; Reactor线程数，reactor_num => 2，通过此参数来调节主进程内事件处理线程的数量，以充分利用多核。默认会启用CPU核数相同的数量
server.reactor_num=4

; 设置启动的worker进程数。
; 业务代码是全异步非阻塞的，这里设置为CPU的1-4倍最合理
; 业务代码为同步阻塞，需要根据请求响应时间和系统负载来调整
server.worker_num=4 

; 设置worker进程的最大任务数，默认为0，一个worker进程在处理完超过此数值的任务后将自动退出，进程退出后会释放所有内存和资源。
server.max_request=500

; 服务器程序，最大允许的连接数，如max_connection => 10000, 此参数用来设置Server最大允许维持多少个TCP连接。超过此数量后，新进入的连接将被拒绝。
; max_connection最大不得超过操作系统ulimit -n的值，否则会报一条警告信息，并重置为ulimit -n的值
; max_connection默认值为ulimit -n的值
; 最大上限
; 底层使用了SESSION_LIST来实现session_id（虚拟fd）与真实fd的对应，因此除了max_sockets限制之外，max_connection还受限于SW_SESSION_LIST_SIZE宏的设置。
; 目前SW_SESSION_LIST_SIZE底层的值为1M，请勿设置max_connection超过1M

; 内存占用
; max_connection参数不要调整的过大，根据机器内存的实际情况来设置。Swoole会根据此数值一次性分配一块大内存来保存Connection信息，可使用gdb跟踪运行中的进程，打印p sizeof(swConnection) 得到准确的数值。在1.9.16版本中一个TCP连接的Connection信息，需要占用224字节。

; 最小设置
; 此选项设置过小底层会抛出错误，并设置为ulimit -n的值。
; 最小值为(serv->worker_num + SwooleG.task_worker_num) * 2 + 32

server.max_conn=1000

; 配置Task进程的数量，配置此参数后将会启用task功能。所以Server务必要注册onTask、onFinish2个事件回调函数。如果没有注册，服务器程序将无法启动。
; Task进程是同步阻塞的，配置方式与Worker同步模式一致。
; 计算方法
; 单个task的处理耗时，如100ms，那一个进程1秒就可以处理1/0.1=10个task
; task投递的速度，如每秒产生2000个task
; 2000/10=200，需要设置task_worker_num => 200，启用200个task进程
; Task进程内不能使用swoole_server->task方法
; Task进程内不能使用swoole_mysql、swoole_redis、swoole_event等异步IO函数
server.task_worker_num=4

; 设置task进程与worker进程之间通信的方式。

; 1, 使用unix socket通信，默认模式
; 2, 使用消息队列通信
; 3, 使用消息队列通信，并设置为争抢模式
; 模式2和模式3的不同之处是，模式2支持定向投递，$serv->task($data, $task_worker_id) 可以指定投递到哪个task进程。模式3是完全争抢模式，task进程会争抢队列，将无法使用定向投递，task/taskwait将无法指定目标进程ID，即使指定了$task_worker_id，在模式3下也是无效的。

; 模式3会影响sendMessage方法，使sendMessage发送的消息会随机被某一个task进程获取
server.task_ipc_mode=1

; 设置task进程的最大任务数。一个task进程在处理完超过此数值的任务后将自动退出。这个参数是为了防止PHP进程内存溢出。如果不希望进程自动退出可以设置为0。
server.task_max_request=100

; 设置task的数据临时目录，在swoole_server中，如果投递的数据超过8192字节，将启用临时文件来保存数据。task_tmpdir就是用来设置临时文件保存的位置
; Swoole默认会使用/tmp目录存储task数据，如果你的Linux内核版本过低，/tmp目录不是内存文件系统，可以设置为 /dev/shm/
server.task_tmpdir=/tmp

; 数据包分发策略。可以选择3种类型，默认为2
; 1，轮循模式，收到会轮循分配给每一个worker进程
; 2，固定模式，根据连接的文件描述符分配worker。这样可以保证同一个连接发来的数据只会被同一个worker处理
; 3，抢占模式，主进程会根据Worker的忙闲状态选择投递，只会投递给处于闲置状态的Worker
; 4，IP分配，根据客户端IP进行取模hash，分配给一个固定的worker进程。可以保证同一个来源IP的连接数据总会被分配到同一个worker进程。算法为 ip2long(ClientIP) % worker_num
; 5，UID分配，需要用户代码中调用 $serv-> bind() 将一个连接绑定1个uid。然后swoole根据UID的值分配到不同的worker进程。算法为 UID % worker_num，如果需要使用字符串作为UID，可以使用crc32(UID_STRING)
server.dispatch_mode=2

; 设置dispatch函数，swoole底层了内置了5种dispatch_mode，如果仍然无法满足需求。可以使用编写C++函数或PHP函数，实现dispatch逻辑。使用方法：

; $serv->set(array(
;     'dispatch_func' => 'my_dispatch_function',
; ));
; 设置dispatch_func后底层会自动忽略dispatch_mode配置
; dispatch_func对应的函数不存在，底层将抛出致命错误
; 如果需要dispatch一个超过8K的包，dispatch_func只能获取到 0-8180 字节的内容
server.dispatch_func=user_function

; 设置消息队列的KEY，仅在task_ipc_mode = 2/3时使用。设置的Key仅作为Task任务队列的KEY，此参数的默认值为ftok($php_script_file, 1)
; task队列在server结束后不会销毁，重新启动程序后，task进程仍然会接着处理队列中的任务。如果不希望程序重新启动后不执行旧的Task任务。可以手工删除此消息队列。
server.message_queue_key=message_key


; 守护进程化。设置daemonize => 1时，程序将转入后台作为守护进程运行。长时间运行的服务器端程序必须启用此项。
; 如果不启用守护进程，当ssh终端退出后，程序将被终止运行。
; 启用守护进程后，标准输入和输出会被重定向到 log_file
; 如果未设置log_file，将重定向到 /dev/null，所有打印屏幕的信息都会被丢弃
; 启用守护进程后，CWD（当前目录）环境变量的值会发生变更，相对路径的文件读写会出错。PHP程序中必须使用绝对路径
server.daemonize=1


; Listen队列长度，如backlog => 128，此参数将决定最多同时有多少个等待accept的连接。
server.backlog=256


; log_file => '/data/log/swoole.log', 指定swoole错误日志文件。在swoole运行期发生的异常信息会记录到这个文件中。默认会打印到屏幕。
; 注意log_file不会自动切分文件，所以需要定期清理此文件。观察log_file的输出，可以得到服务器的各类异常信息和警告。
; log_file中的日志仅仅是做运行时错误记录，没有长久存储的必要。
; 开启守护进程模式后(daemonize => true)，标准输出将会被重定向到log_file。在PHP代码中echo/var_dump/print等打印到屏幕的内容会写入到log_file文件
; TODO
; 日志自动分片功能
; 实现发信息给Server

server.log_file=/tmp/swoole.log

; 设置swoole_server错误日志打印的等级，范围是0-5。低于log_level设置的日志信息不会抛出。
; 需要实现Log类常量
; 0 =>DEBUG
; 1 =>TRACE
; 2 =>INFO
; 3 =>NOTICE
; 4 =>WARNING
; 5 =>ERROR
server.log_level=DEBUG


; 启用心跳检测，此选项表示每隔多久轮循一次，单位为秒。如 heartbeat_check_interval => 60，表示每60秒，遍历所有连接，如果该连接在60秒内，没有向服务器发送任何数据，此连接将被强制关闭。
; swoole_server并不会主动向客户端发送心跳包，而是被动等待客户端发送心跳。服务器端的heartbeat_check仅仅是检测连接上一次发送数据的时间，如果超过限制，将切断连接。
; heartbeat_check仅支持TCP连接
server.heartbeat_check_interval=60


; 与heartbeat_check_interval配合使用。表示连接最大允许空闲的时间。如
; array(
;     'heartbeat_idle_time' => 600,
;     'heartbeat_check_interval' => 60,
; );
; 表示每60秒遍历一次，一个连接如果600秒内未向服务器发送任何数据，此连接将被强制关闭
; 启用heartbeat_idle_time后，服务器并不会主动向客户端发送数据包
; 如果只设置了heartbeat_idle_time未设置heartbeat_check_interval底层将不会创建心跳检测线程，PHP代码中可以调用heartbeat方法手工处理超时的连接
server.heartbeat_idle_time=120


; 打开EOF检测，此选项将检测客户端连接发来的数据，当数据包结尾是指定的字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止。当出错时swoole底层会认为是恶意连接，丢弃数据并强制关闭连接。
; array(
; 'open_eof_check' => true, //打开EOF检测
; 'package_eof' => "\r\n", //设置EOF
; )
; 常见的Memcache/SMTP/POP等协议都是以\r\n结束的，就可以使用此配置。开启后可以保证Worker进程一次性总是收到一个或者多个完整的数据包。
server.open_eof_check=true

; 启用EOF自动分包。当设置open_eof_check后，底层检测数据是否以特定的字符串结尾来进行数据缓冲。但默认只截取收到数据的末尾部分做对比。这时候可能会产生多条数据合并在一个包内。
; 启用open_eof_split参数后，底层会从数据包中间查找EOF，并拆分数据包。onReceive每次仅收到一个以EOF字串结尾的数据包。
; 启用open_eof_split参数后，无论参数open_eof_check是否设置，open_eof_split都将生效。
server.open_eof_split=true

; 与 open_eof_check 或者 open_eof_split 配合使用，设置EOF字符串。
; package_eof最大只允许传入8个字节的字符串
server.package_eof=\r\n


; 打开包长检测特性。包长检测提供了固定包头+包体这种格式协议的解析。启用后，可以保证Worker进程onReceive每次都会收到一个完整的数据包。
; 长度协议提供了3个选项来控制协议细节。
server.open_length_check=

; 包头中某个字段作为包长度的值，底层支持了10种长度类型。请参考 package_length_type
server.package_length_type=

; 从第几个字节开始计算长度，一般有2种情况：
; length的值包含了整个包（包头+包体），package_body_offset 为0
; 包头长度为N字节，length的值不包含包头，仅包含包体，package_body_offset设置为N
server.package_body_offset=

; length长度值在包头的第几个字节。
server.package_length_offset=

; 设置长度解析函数，支持C++或PHP的2种类型的函数。长度函数必须返回一个整数。
; 返回0，数据不足，需要接收更多数据
; 返回-1，数据错误，底层会自动关闭连接
; 返回包长度值（包括包头和包体的总长度），底层会自动将包拼好后返回给回调函数
; 默认底层最大会读取8K的数据，如果包头的长度较小可能会存在内存复制的消耗。可设置package_body_offset参数，底层只读取包头进行长度解析。
server.package_length_func=user_function

; 设置最大数据包尺寸，单位为字节。开启open_length_check/open_eof_check/open_http_protocol等协议解析后。swoole底层会进行数据包拼接。这时在数据包未收取完整时，所有数据都是保存在内存中的。
; 所以需要设定package_max_length，一个数据包最大允许占用的内存尺寸。如果同时有1万个TCP连接在发送数据，每个数据包2M，那么最极限的情况下，就会占用20G的内存空间。
; open_length_check，当发现包长度超过package_max_length，将直接丢弃此数据，并关闭连接，不会占用任何内存。包括websocket、mqtt、http2协议。
; open_eof_check，因为无法事先得知数据包长度，所以收到的数据还是会保存到内存中，持续增长。当发现内存占用已超过package_max_length时，将直接丢弃此数据，并关闭连接
; open_http_protocol，GET请求最大允许8K，而且无法修改配置。POST请求会检测Content-Length，如果Content-Length超过package_max_length，将直接丢弃此数据，发送http 400错误，并关闭连接
; 此参数不宜设置过大，否则会占用很大的内存
server.package_max_length=100


; 启用CPU亲和性设置。在多核的硬件平台中，启用此特性会将swoole的reactor线程/worker进程绑定到固定的一个核上。可以避免进程/线程的运行时在多个核之间互相切换，提高CPU Cache的命中率。
; 使用taskset命令查看进程的CPU亲和设置：
; taskset -p 进程ID
; pid 24666's current affinity mask: f
; pid 24901's current affinity mask: 8
; mask是一个掩码数字，按bit计算每bit对应一个CPU核，如果某一位为0表示绑定此核，进程会被调度到此CPU上，为0表示进程不会被调度到此CPU。
; 示例中pid为24666的进程mask = f 表示未绑定到CPU，操作系统会将此进程调度到任意一个CPU核上。 pid为24901的进程mask = 8，8转为二进制是 1000，表示此进程绑定在第4个CPU核上。
server.open_cpu_affinity=


; IO密集型程序中，所有网络中断都是用CPU0来处理，如果网络IO很重，CPU0负载过高会导致网络中断无法及时处理，那网络收发包的能力就会下降。
; 如果不设置此选项，swoole将会使用全部CPU核，底层根据reactor_id或worker_id与CPU核数取模来设置CPU绑定。
; 如果内核与网卡有多队列特性，网络中断会分布到多核，可以缓解网络中断的压力
; 此选项必须与open_cpu_affinity同时设置才会生效
server.cpu_affinity_ignore=array(0)

; 启用open_tcp_nodelay，开启后TCP连接发送数据时会关闭Nagle合并算法，立即发往客户端连接。在某些场景下，如http服务器，可以提升响应速度。
server.open_tcp_nodelay=true

; 启用tcp_defer_accept特性，可以设置为一个数值，表示当一个TCP连接有数据发送时才触发accept。
; tcp_defer_accept => 5
; 启用tcp_defer_accept特性后，accept和onConnect对应的时间会发生变化。如果设置为5秒：
; 客户端连接到服务器后不会立即触发accept
; 在5秒内客户端发送数据，此时会同时顺序触发accept/onConnect/onReceive
; 在5秒内客户端没有发送任何数据，此时会触发accept/onConnect
; tcp_defer_accept的可以提高Accept操作的效率
server.tcp_defer_accept=5

; 设置OpenSSL隧道加密的算法。Server与Client使用的算法必须一致，否则SSL/TLS握手会失败，连接会被切断。 默认算法为 SWOOLE_SSLv23_METHOD
server.ssl_method=SWOOLE_SSLv3_CLIENT_METHOD

; 启用SSL后，设置ssl_ciphers来改变openssl默认的加密算法。Swoole底层默认使用EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH
; 某些低版本浏览器可能不支持默认的加密套件，可设置为空字符串兼容低版本浏览器
; 启用http2协议后，Chrome/Firefox等浏览器要求必须使用高强度加密套件
server.ssl_ciphers=EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH

; 设置worker/task子进程的所属用户。服务器如果需要监听1024以下的端口，必须有root权限。但程序运行在root用户下，代码中一旦有漏洞，攻击者就可以以root的方式执行远程指令，风险很大。配置了user项之后，可以让主进程运行在root权限下，子进程运行在普通用户权限下。
; 仅在使用root用户启动时有效
server.user=www


; 设置worker/task子进程的进程用户组。与user配置相同，此配置是修改进程所属用户组，提升服务器程序的安全性。
; $serv->set(array('group' => 'www-data'));
; 此配置在swoole-1.7.9以上版本可用
; 仅在使用root用户启动时有效
server.group=www

; 重定向Worker进程的文件系统根目录。此设置可以使进程对文件系统的读写与实际的操作系统文件系统隔离。提升安全性。
; $serv->set(array('chroot' => '/data/server/'))
server.chroot=/www/wwwroot

; 在Server启动时自动将master进程的PID写入到文件，在Server关闭时自动删除PID文件。
; $server->set(array(
;     'pid_file' => __DIR__.'/server.pid',
; ));
; 使用时需要注意如果Server非正常结束，PID文件不会删除，需要使用swoole_process::kill($pid, 0)来侦测进程是否真的存在
server.pid_file=/www/wwwroot/server.pid

; 调整管道通信的内存缓存区长度。Swoole使用Unix Socket实现进程间通信。
; $server->set([
;     'pipe_buffer_size' => 32 * 1024 *1024, //必须为数字
; ])
; swoole的reactor线程与worker进程之间
; worker进程与task进程之间
; 1.9.16或更高版本已移除此配置项，底层不再限制管道缓存区的长度
; 都是使用unix socket进行通信的，在收发大量数据的场景下，需要启用内存缓存队列。此函数可以修改内存缓存的长度。
; task_ipc_mode=2/3时会使用消息队列通信不受此参数控制
; 管道缓存队列已满会导致reactor线程、worker进程发生阻塞
server.pipe_buffer_size=256

; 配置发送输出缓存区内存尺寸。
; $server->set([
;     'buffer_output_size' => 32 * 1024 *1024, //必须为数字
; ])
; 单位为字节，默认为2M，如设置32 * 1024 *1024表示，单次Server->send最大允许发送32M字节的数据
; 调用swoole_server->send， swoole_http_server->end/write，swoole_websocket_server->push 等发送数据指令时，单次最大发送的数据不得超过buffer_output_size配置。
; 注意此函数不应当调整过大，避免拥塞的数据过多，导致吃光机器内存
; 开启大量worker进程时，将会占用worker_num * buffer_output_size字节的内存
server.buffer_output_size=2560


; swoole在配置dispatch_mode=1或3后，因为系统无法保证onConnect/onReceive/onClose的顺序，默认关闭了onConnect/onClose事件。
; 如果应用程序需要onConnect/onClose事件，并且能接受顺序问题可能带来的安全风险，可以通过设置enable_unsafe_event为true，启用onConnect/onClose事件
server.enable_unsafe_event=true


; swoole在配置dispatch_mode=1或3后，系统无法保证onConnect/onReceive/onClose的顺序，因此可能会有一些请求数据在连接关闭后，才能到达Worker进程。
; discard_timeout_request配置默认为true，表示如果worker进程收到了已关闭连接的数据请求，将自动丢弃。discard_timeout_request如果设置为false，表示无论连接是否关闭Worker进程都会处理数据请求。
server.discard_timeout_request=true


; 设置端口重用，此参数用于优化TCP连接的Accept性能，启用端口重用后多个进程可以同时进行Accept操作。
; enable_reuse_port = true 打开端口重用
; enable_reuse_port = false 关闭端口重用
; 仅在Linux-3.9.0以上版本的内核可用
; 启用端口重用后可以重复启动同一个端口的Server程序
server.enable_reuse_port=true


; 设置此选项为true后，accept客户端连接后将不会自动加入EventLoop，仅触发onConnect回调。worker进程可以调用$serv->confirm($fd)对连接进行确认，此时才会将fd加入EventLoop开始进行数据收发，也可以调用$serv->close($fd)关闭此连接。
server.enable_delay_receive=true


; 启用Http协议处理，Swoole\Http\Server会自动启用此选项。设置为false表示关闭Http协议处理。
server.open_http_protocol=true

; 启用HTTP2协议解析，需要依赖--enable-http2编译选项。默认为false
server.open_http2_protocol=true

; 启用websocket协议处理，Swoole\WebSocket\Server会自动启用此选项。设置为false表示关闭websocket协议处理。
; 设置open_websocket_protocol选项为true后，会自动设置open_http_protocol协议也为true。
server.open_websocket_protocol=true


; 启用mqtt协议处理，启用后会解析mqtt包头，worker进程onReceive每次会返回一个完整的mqtt数据包。
; $serv->set(array('open_mqtt_protocol' => true));
server.open_mqtt_protocol=true

; 设置异步重启开关。设置为true时，将启用异步安全重启特性，Worker进程会等待异步事件完成后再退出
server.reload_async=true

; 开启请求慢日志。启用后Manager进程会设置一个时钟信号，定时侦测所有Task和Worker进程，一旦进程阻塞导致请求超过规定的时间，将自动打印进程的PHP函数调用栈。
; 底层基于ptrace系统调用实现，某些系统可能关闭了ptrace，无法跟踪慢请求。请确认kernel.yama.ptrace_scope内核参数是否0。
; array(
;     'request_slowlog_file' => '/tmp/trace.log',
; )
; 与trace_event_worker和request_slowlog_timeout配置项配合使用。
; 注意事项
; 需要1.10.0或更高版本
; 仅在同步阻塞的程序中有效，请勿使用与协程和异步回调的服务器中
; 必须是具有可写权限的文件，否则创建文件失败底层会抛出致命错误
; 默认仅监听Task进程，通过增加trace_event_worker => true来开启对Worker进程的跟踪
; 超时时间
; 通过request_slowlog_timeout来设置请求超时时间，单位为秒。

; array(
;     'request_slowlog_timeout' => 2, //2秒
;     'request_slowlog_file' => '/tmp/trace.log',
;     'trace_event_worker' => true, //跟踪 Task 和 Worker 进程
; )
server.request_slowlog_file=string

; 设置上传文件的临时目录，目录最大长度不得超过220字节
server.http.upload_tmp_dir=string

; 设置POST消息解析开关，选项为true时自动将Content-Type为x-www-form-urlencoded的请求包体解析到POST数组。设置为false时将关闭POST解析。
server.http.http_parse_post=true

; 配置静态文件根目录，与enable_static_handler配合使用。
server.http.document_root=string
